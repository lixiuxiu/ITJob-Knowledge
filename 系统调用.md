操作系统面试题

# 系统调用

## 内核态和用户态

### 用户态和内核态的切换

当在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成一些用户态自己没有特权和能力完成的操作时就会切换到内核态。

### 用户态切换到内核态的3种方式

（1）系统调用

这是用户态进程主动要求切换到内核态的一种方式。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。例如fork（）就是执行了一个创建新进程的系统调用。系统调用的机制和新是使用了操作系统为用户特别开放的一个中断来实现，如Linux的int 80h中断。

（2）异常

当cpu在执行运行在用户态下的程序时，发生了一些没有预知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常。

（3）外围设备的中断

当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令而转到与中断信号对应的处理程序去执行，如果前面执行的指令时用户态下的程序，那么转换的过程自然就会是 由用户态到内核态的切换。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等

### 内核

内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。

## 系统调用概念

应用程序的执行必须依托于内核提供的资源，凡是与资源有关的操作（如CPU资源、存储资源、进行I/0传输以及管理文件等)要在内核态下完成，为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。**所以所谓系统调用由操作系统实现提供的应用编程接口(API)**。是应用程序同系统之间的接口。显然，系统调用运行在系统的核心态。通过系统调用的方式来使用系统功能，**可以保证系统的稳定性和安全性**，防止用户随意更改或访问系统的数据或命令。系统调用命令是由操作系统提供的一个或多个子程序模块实现的。

这些系统调用按功能大致可分为如下几类：

- 设备管理。完成设备的请求或释放，以及设备启动等功能。
- 文件管理。完成文件的读、写、创建及删除等功能。
- 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
- 进程通信。完成进程之间的消息传递或信号传递等功能。
- 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。



这样，操作系统的运行环境可以理解为：用户通过操作系统运行上层程序（如系统提供的命令解释程序或用户自编程序)，而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序；也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。当管理程序运行结束时，用户程序需要继续运行，则通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行。

在操作系统这一层面上，我们关心的是系统核心态和用户态的软件实现和切换，对于硬件层面的具体理解，可以结合“计算机组成原理”课程中有关中断的内容进行学习。

下面列举一些由用户态转向核心态的例子：

- 用户程序要求操作系统的服务，即系统调用。
- 发生一次中断。
- 用户程序中产生了一个错误状态。
- 用户程序中企图执行一条特权指令。
- 从核心态转向用户态由一条指令实现，这条指令也是特权命令。一般是中断返回指令。

注意：由用户态进入核心态，不仅仅是状态需要切换。而且，所使用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的。



## 1 CPU的内核模式和用户模式

通常，处理器设有两种模式：“用户模式”与“内核模式”，通过一个标签位来鉴别当前正处于什么模式。内核模式可以运行所有指令，包括特权指令（主要是一些硬件管理的指令，例如修改基址寄存器内容的指令） ，而用户模式不能执行特权指令。这样的设计主要为了安全问题，即由操作系统负责管理硬件，避免上层应用因错误设计而导致硬件问题。

既然只有操作系统能直接操作硬件，操作系统有必要提供接口来为应用程序提供使用硬件功能的入口，这些接口就被称为系统调用。

当操作系统接收到系统调用请求后，会让处理器进入内核模式，从而执行诸如I/O操作，修改基址寄存器内容等指令，而当处理完系统调用内容后，操作系统会让处理器返回用户模式，来执行用户代码。

## 2 系统调用和中断的联系

中断（Interrupt）通常是指在CPU内部或外部发生了某个待处理的事件，从而CPU必需改变当前指令的执行顺序去处理这类事件。

中断大致分为外中断和内中断/异常，而系统调用时内中断的一种，由程序员的代码主动发起的中断，用来实现系统调用。

## 3 内核对于系统调用的处理

在x86的机器中，用一个8bit的数字（0~255）来区分各种中断，这个数字被称为中断向量（vector）。其中一个中断向量，即128 （0x80），专门被用于执行系统调用。

在Linux系统中，存有一个系统表，叫做Interrupt DescriptorTable，简称IDT。IDT表共有256项，存放了从中断向量到相应处理例程（interrupt or exceptionhandler）的映射关系。当某个中断发生时，CPU从IDT表中查找到相应的处理例程的地址来执行。

系统调用的处理例程在IDT表中占有一项。这一项是在trap_init函数中被初始化的，如下：`set_system_gate(SYSCALL_VECTOR,&system_call);`。如前所述，上面代码中的SYSCALL_VECTOR的值是128。

当系统调用发生时，通过中断机制，系统调用例程system_call被调用。它的执行过程大概分为4个步骤：

1. 从寄存器中取出系统调用号和输入参数，然后将这些寄存器的值压入kernel栈中。
2. 根据系统调用号查找系统调用分派表（system call dispatch table），找到系统调用服务例程（一个内核函数）。
3. 调用查到的系统调用服务例程。
4. 将系统调用服务例程的返回值出栈，重新保存在寄存器中。

上面描述的系统调用例程system_call在kernel空间中执行。在执行前，系统调用号和输入参数已经存入了寄存器，这个存入过程由user空间的代码完成。实际上，如同第一节所讲，每个真正的系统调用基本上都有一个封装它的库函数，一般是在这个库函数中完成系统调用号和输入参数的保存动作。当系统调用例程system_call执行完毕后，返回值通过寄存器再传回user空间的库函数。

库函数主要由两方面提供：一是操作系统提供的；另一类是由第三方提供的。

- 系统提供的这些函数把系统调用进行封装或者组合，可以实现更多的功能，这样的库函数能够实现一些对于内核来说比较复杂的操作。比如read函数根据参数，直接就能读文件，而背后隐藏的文件比如在那个磁道，那个扇区，加载到那个内存，是程序员不必关心的问题。这些操作里面也包含了系统调用。比如write()这个系统函数，会调用同名的系统调用，来完成写入操作。
- 对于第三方库，其实和系统库一样，只是他直接利用系统调用的可能性要小一些，而是系统提供的API接口来是实现。比如printf，实际上调用了write()这个系统函数。 第三方库函数大部分是对系统函数的封装。